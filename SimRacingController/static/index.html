<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SimRacing Orchestrator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0d1f4a 0%, #1a3a7a 100%);
            color: #fff;
            padding: 12px;
            font-size: clamp(14px, 1.3vw, 20px);
            line-height: 1.3;
        }

        .container {
            max-width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        h1 {
            text-align: center;
            font-size: clamp(1.5em, 3vw, 2.5em);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 1px;
            flex-shrink: 0;
        }

        /* Slot Pool Area */
        .slot-pool {
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 12px 15px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            flex-shrink: 0;
        }

        .slot-pool h2 {
            margin-bottom: 10px;
            font-size: 1.3em;
            font-weight: 700;
        }

        .slots-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }

        /* Slot Cards */
        .slot-card {
            background: rgba(255, 255, 255, 0.18);
            border-radius: 10px;
            padding: 12px 15px;
            border: 3px solid rgba(255, 255, 255, 0.4);
            cursor: grab;
            transition: all 0.3s ease;
            user-select: none;
        }

        .slot-card:active {
            cursor: grabbing;
        }

        .slot-card.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .slot-card.offline {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #ff6b6b;
            background: rgba(255, 100, 100, 0.1);
        }

        .slot-card.online {
            border-color: #51cf66;
            box-shadow: 0 0 15px rgba(81, 207, 102, 0.3);
        }

        .slot-card.running {
            border-color: #339af0;
            background: rgba(51, 154, 240, 0.25);
            box-shadow: 0 0 15px rgba(51, 154, 240, 0.3);
        }

        .slot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .slot-number {
            font-size: 1.2em;
            font-weight: 800;
        }

        .status-dot {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            animation: pulse 2s infinite;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .status-dot.online {
            background: #51cf66;
            box-shadow: 0 0 10px #51cf66;
        }

        .status-dot.offline {
            background: #ff6b6b;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 10px #51cf66; }
            50% { opacity: 0.6; box-shadow: 0 0 5px #51cf66; }
        }

        .client-name {
            font-size: 1.1em;
            font-weight: 700;
            margin-bottom: 3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .client-status {
            font-size: 0.95em;
            opacity: 0.9;
        }

        .current-game {
            margin-top: 6px;
            padding: 5px 8px;
            background: rgba(51, 154, 240, 0.5);
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: bold;
        }

        /* Game Areas Container - fills remaining space */
        .game-areas-wrapper {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            min-height: 0;
        }

        /* Game Area Drop Zone */
        .game-area {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 12px;
            border: 3px dashed rgba(255, 255, 255, 0.4);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .game-area.drag-over {
            border-color: #51cf66;
            background: rgba(81, 207, 102, 0.25);
            transform: scale(1.01);
        }

        .game-area-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            flex-shrink: 0;
        }

        .game-title {
            font-size: 1.15em;
            font-weight: 800;
        }

        .game-icon {
            font-size: 1.5em;
        }

        .assigned-slots {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            margin: 8px 0;
            display: flex;
            flex-direction: column;
        }

        .assigned-slots h3 {
            font-size: 0.95em;
            margin-bottom: 8px;
            opacity: 0.9;
            font-weight: 600;
        }

        .assigned-slot-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 6px;
            flex: 1;
            min-height: 0;
        }

        .assigned-slot-item {
            background: rgba(255, 255, 255, 0.15);
            padding: 8px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            cursor: grab;
            transition: all 0.2s;
            font-size: 0.95em;
            border: 2px solid rgba(255,255,255,0.2);
            min-height: 0;
            overflow: hidden;
        }

        .assigned-slot-item:hover {
            background: rgba(255, 255, 255, 0.22);
        }

        .assigned-slot-item:active {
            cursor: grabbing;
        }

        .assigned-slot-item.dragging {
            opacity: 0.5;
        }

        .assigned-slot-info {
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
            margin-bottom: 4px;
        }

        .assigned-slot-controls {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .slot-btn {
            padding: 6px 10px;
            border: none;
            border-radius: 5px;
            font-size: 0.8em;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .slot-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .slot-btn.start {
            background: #40c057;
            color: white;
            box-shadow: 0 3px 8px rgba(64, 192, 87, 0.4);
        }

        .slot-btn.start:hover:not(:disabled) {
            background: #37b24d;
            transform: scale(1.05);
        }

        .slot-btn.stop {
            background: #fa5252;
            color: white;
            box-shadow: 0 3px 8px rgba(250, 82, 82, 0.4);
        }

        .slot-btn.stop:hover:not(:disabled) {
            background: #e03131;
            transform: scale(1.05);
        }

        .assigned-slot-item .role-badge {
            padding: 5px 10px;
            background: rgba(51, 154, 240, 0.5);
            border-radius: 5px;
            font-size: 0.85em;
            font-weight: 800;
            text-transform: uppercase;
        }

        .assigned-slot-item .role-badge.host {
            background: rgba(255, 193, 7, 0.6);
            color: #fff;
        }

        .area-controls {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
            margin-top: auto;
        }

        .area-btn {
            flex: 1;
            padding: 12px 8px;
            border: none;
            border-radius: 8px;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            font-size: 0.95em;
            letter-spacing: 0.5px;
        }

        .area-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .area-btn.start {
            background: #40c057;
            color: white;
            box-shadow: 0 4px 12px rgba(64, 192, 87, 0.4);
        }

        .area-btn.start:hover:not(:disabled) {
            background: #37b24d;
            transform: scale(1.02);
        }

        .area-btn.stop {
            background: #fa5252;
            color: white;
            box-shadow: 0 4px 12px rgba(250, 82, 82, 0.4);
        }

        .area-btn.stop:hover:not(:disabled) {
            background: #e03131;
            transform: scale(1.02);
        }

        .area-info {
            padding: 8px;
            background: rgba(51, 154, 240, 0.3);
            border-radius: 6px;
            margin: 8px 0;
            font-size: 0.9em;
            text-align: center;
            font-weight: 600;
            flex-shrink: 0;
        }

        /* Empty state */
        .empty-state {
            grid-column: 1 / -1;
            grid-row: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px 10px;
            opacity: 0.6;
            font-style: italic;
            font-size: 1em;
        }

        /* Message - fixed at bottom */
        .message {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 25px;
            border-radius: 10px;
            display: none;
            font-size: 1em;
            font-weight: 600;
            z-index: 1000;
            max-width: 90%;
        }

        .message.show {
            display: block;
        }

        .message.success {
            background: rgba(64, 192, 87, 0.9);
            border: 2px solid #40c057;
        }

        .message.error {
            background: rgba(250, 82, 82, 0.9);
            border: 2px solid #fa5252;
        }

        /* Hide separate singleplayer/multiplayer wrappers - we use unified grid now */
        .singleplayer-areas,
        .multiplayer-areas {
            display: contents;
        }

        /* Responsive for smaller screens */
        @media (max-width: 1400px) {
            .game-areas-wrapper {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 1000px) {
            .game-areas-wrapper {
                grid-template-columns: repeat(2, 1fr);
            }

            .slots-container {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 700px) {
            .game-areas-wrapper {
                grid-template-columns: 1fr;
            }

            .slots-container {
                grid-template-columns: 1fr;
            }
        }

        /* Scrollbar styling for assigned slots */
        .assigned-slots::-webkit-scrollbar {
            width: 6px;
        }

        .assigned-slots::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }

        .assigned-slots::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        .assigned-slots::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèÅ SimRacing Orchestrator</h1>

        <!-- Slot Pool -->
        <div class="slot-pool">
            <h2>Available Clients</h2>
            <div class="slots-container" id="slotsContainer">
                <!-- Slot cards will be populated here -->
            </div>
        </div>

        <!-- All Game Areas in unified grid -->
        <div class="game-areas-wrapper">
            <!-- F1 22 Singleplayer -->
            <div class="game-area" data-game="f1_22" data-mode="singleplayer" data-area-id="f1_sp">
                <div class="game-area-header">
                    <div class="game-title">F1 22 Solo</div>
                </div>
                <div class="assigned-slots">
                    <div class="assigned-slot-list" id="slots-f1_sp">
                        <div class="empty-state">Drag slots here</div>
                    </div>
                </div>
            </div>

            <!-- ACC Singleplayer -->
            <div class="game-area" data-game="acc" data-mode="singleplayer" data-area-id="acc_sp">
                <div class="game-area-header">
                    <div class="game-title">ACC Solo</div>
                </div>
                <div class="assigned-slots">
                    <div class="assigned-slot-list" id="slots-acc_sp">
                        <div class="empty-state">Drag slots here</div>
                    </div>
                </div>
            </div>

            <!-- DIRT Rally 2 Singleplayer -->
            <div class="game-area" data-game="dirt_rally_2" data-mode="singleplayer" data-area-id="dirt_sp">
                <div class="game-area-header">
                    <div class="game-title">DIRT Rally 2 Solo</div>
                </div>
                <div class="assigned-slots">
                    <div class="assigned-slot-list" id="slots-dirt_sp">
                        <div class="empty-state">Drag slots here</div>
                    </div>
                </div>
            </div>

            <!-- F1 22 Multiplayer Area 1 -->
            <div class="game-area" data-game="f1_22" data-mode="multiplayer" data-area-id="f1_mp1">
                <div class="game-area-header">
                    <div class="game-title">F1 22 Multi 1</div>
                </div>
                <div class="area-info">2+ slots ¬∑ First = Host</div>
                <div class="assigned-slots">
                    <div class="assigned-slot-list" id="slots-f1_mp1">
                        <div class="empty-state">Drag 2+ slots</div>
                    </div>
                </div>
                <div class="area-controls">
                    <button class="area-btn start" onclick="startArea('f1_mp1')" disabled>Start</button>
                    <button class="area-btn stop" onclick="stopArea('f1_mp1')" disabled>Stop</button>
                </div>
            </div>

            <!-- F1 22 Multiplayer Area 2 -->
            <div class="game-area" data-game="f1_22" data-mode="multiplayer" data-area-id="f1_mp2">
                <div class="game-area-header">
                    <div class="game-title">F1 22 Multi 2</div>
                </div>
                <div class="area-info">2+ slots ¬∑ First = Host</div>
                <div class="assigned-slots">
                    <div class="assigned-slot-list" id="slots-f1_mp2">
                        <div class="empty-state">Drag 2+ slots</div>
                    </div>
                </div>
                <div class="area-controls">
                    <button class="area-btn start" onclick="startArea('f1_mp2')" disabled>Start</button>
                    <button class="area-btn stop" onclick="stopArea('f1_mp2')" disabled>Stop</button>
                </div>
            </div>
        </div>

        <div id="message" class="message"></div>
    </div>

    <script>
        const ORCHESTRATOR_URL = window.location.origin;

        let slots = {};
        let slotAssignments = {
            'pool': [1, 2, 3, 4],  // Initially all in pool
            'f1_sp': [],
            'acc_sp': [],
            'dirt_sp': [],
            'f1_mp1': [],
            'f1_mp2': []
        };

        function createSlotCard(slotNum) {
            const card = document.createElement('div');
            card.className = 'slot-card offline';
            card.id = `slot-card-${slotNum}`;
            card.draggable = false;
            card.dataset.slot = slotNum;

            card.innerHTML = `
                <div class="slot-header">
                    <div class="slot-number">Slot ${slotNum}</div>
                    <div class="status-dot offline"></div>
                </div>
                <div class="client-name">Not Connected</div>
                <div class="client-status">Offline</div>
            `;

            // Drag events
            card.addEventListener('dragstart', handleDragStart);
            card.addEventListener('dragend', handleDragEnd);

            return card;
        }

        function initializeSlots() {
            const container = document.getElementById('slotsContainer');
            container.innerHTML = '';

            for (let i = 1; i <= 4; i++) {
                const card = createSlotCard(i);
                container.appendChild(card);
            }

            // Initialize drop zones
            document.querySelectorAll('.game-area').forEach(area => {
                area.addEventListener('dragover', handleDragOver);
                area.addEventListener('drop', handleDrop);
                area.addEventListener('dragleave', handleDragLeave);
            });

            // Pool is also a drop zone
            const pool = document.getElementById('slotsContainer');
            pool.addEventListener('dragover', handleDragOver);
            pool.addEventListener('drop', handleDropToPool);
            pool.addEventListener('dragleave', handleDragLeave);
        }

        let draggedSlot = null;
        let draggedFromArea = null;

        function handleDragStart(e) {
            const slotNum = parseInt(e.target.dataset.slot);
            const slot = slots[`slot_${slotNum}`];

            // Only allow dragging if online
            if (!slot || !slot.online) {
                e.preventDefault();
                return;
            }

            draggedSlot = slotNum;
            draggedFromArea = 'pool';
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedSlot = null;
            draggedFromArea = null;
        }

        function handleAssignedSlotDragStart(e) {
            const slotNum = parseInt(e.target.dataset.slot);
            const fromArea = e.target.dataset.fromArea;

            draggedSlot = slotNum;
            draggedFromArea = fromArea;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.stopPropagation();
        }

        function handleAssignedSlotDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedSlot = null;
            draggedFromArea = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            const area = e.currentTarget;
            if (area.classList.contains('game-area')) {
                area.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            const area = e.currentTarget;
            if (area.classList.contains('game-area')) {
                area.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            const area = e.currentTarget;
            area.classList.remove('drag-over');

            if (!draggedSlot) return;

            const areaId = area.dataset.areaId;

            // Don't do anything if dropping in the same area
            if (draggedFromArea === areaId) {
                return;
            }

            // Remove from current assignment
            if (draggedFromArea && slotAssignments[draggedFromArea]) {
                const index = slotAssignments[draggedFromArea].indexOf(draggedSlot);
                if (index > -1) {
                    slotAssignments[draggedFromArea].splice(index, 1);
                }
            }

            // Add to new area
            slotAssignments[areaId].push(draggedSlot);

            updateAllAreas();
        }

        function handleDropToPool(e) {
            e.preventDefault();
            const pool = e.currentTarget;
            pool.classList.remove('drag-over');

            if (!draggedSlot) return;

            // Don't do anything if already in pool
            if (draggedFromArea === 'pool') {
                return;
            }

            // Remove from current assignment
            if (draggedFromArea && slotAssignments[draggedFromArea]) {
                const index = slotAssignments[draggedFromArea].indexOf(draggedSlot);
                if (index > -1) {
                    slotAssignments[draggedFromArea].splice(index, 1);
                }
            }

            // Add back to pool
            slotAssignments['pool'].push(draggedSlot);

            updateAllAreas();
        }

        function updateSlotCard(slotNum) {
            const slot = slots[`slot_${slotNum}`];
            const card = document.getElementById(`slot-card-${slotNum}`);

            if (!card) return;

            const statusDot = card.querySelector('.status-dot');
            const clientName = card.querySelector('.client-name');
            const clientStatus = card.querySelector('.client-status');

            if (slot && slot.online && slot.setup) {
                // Online
                card.classList.remove('offline');
                card.classList.add('online');
                card.draggable = true;
                statusDot.classList.remove('offline');
                statusDot.classList.add('online');
                clientName.textContent = slot.setup.name;
                clientStatus.textContent = `Status: ${slot.setup.status}`;

                // Check if running
                if (slot.setup.current_game) {
                    card.classList.add('running');
                    // Add current game indicator if not exists
                    let gameIndicator = card.querySelector('.current-game');
                    if (!gameIndicator) {
                        gameIndicator = document.createElement('div');
                        gameIndicator.className = 'current-game';
                        card.appendChild(gameIndicator);
                    }
                    gameIndicator.textContent = `üéÆ ${slot.setup.current_game}`;
                } else {
                    card.classList.remove('running');
                    const gameIndicator = card.querySelector('.current-game');
                    if (gameIndicator) gameIndicator.remove();
                }
            } else {
                // Offline
                card.classList.remove('online', 'running');
                card.classList.add('offline');
                card.draggable = false;
                statusDot.classList.remove('online');
                statusDot.classList.add('offline');
                clientName.textContent = 'Not Connected';
                clientStatus.textContent = 'Offline';

                const gameIndicator = card.querySelector('.current-game');
                if (gameIndicator) gameIndicator.remove();
            }
        }

        function updateAllAreas() {
            // Update pool
            const poolContainer = document.getElementById('slotsContainer');
            poolContainer.innerHTML = '';

            slotAssignments['pool'].forEach(slotNum => {
                const card = createSlotCard(slotNum);
                poolContainer.appendChild(card);
                updateSlotCard(slotNum);
            });

            // Update game areas
            ['f1_sp', 'acc_sp', 'dirt_sp', 'f1_mp1', 'f1_mp2'].forEach(areaId => {
                updateGameArea(areaId);
            });
        }

        function updateGameArea(areaId) {
            const container = document.getElementById(`slots-${areaId}`);
            const assignedSlots = slotAssignments[areaId];
            const isMultiplayer = areaId.includes('mp');

            container.innerHTML = '';

            if (assignedSlots.length === 0) {
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-state';
                emptyState.textContent = isMultiplayer ? 'Drag 2+ slots' : 'Drag slots here';
                container.appendChild(emptyState);
            } else {
                assignedSlots.forEach((slotNum, index) => {
                    const slot = slots[`slot_${slotNum}`];
                    const item = document.createElement('div');
                    item.className = 'assigned-slot-item';
                    item.draggable = true;
                    item.dataset.slot = slotNum;
                    item.dataset.fromArea = areaId;

                    const name = slot && slot.setup ? slot.setup.name : `Slot ${slotNum}`;
                    const role = isMultiplayer ? (index === 0 ? 'host' : 'join') : '';

                    // Check if slot is online and running/starting
                    const isOnline = slot && slot.online;
                    const status = slot && slot.setup ? slot.setup.status : 'idle';
                    const isRunning = status === 'running';
                    const isStarting = status === 'starting';
                    const isBusy = isRunning || isStarting;

                    // For singleplayer, add individual start/stop buttons
                    if (!isMultiplayer) {
                        item.innerHTML = `
                            <div class="assigned-slot-info">
                                <span>${name}</span>
                                ${isStarting ? '<span style="margin-left: 8px; font-size: 0.8em; opacity: 0.7;">Starting...</span>' : ''}
                            </div>
                            <div class="assigned-slot-controls">
                                <button class="slot-btn start" onclick="startSlot(event, '${areaId}', ${slotNum})" ${!isOnline || isBusy ? 'disabled' : ''}>Start</button>
                                <button class="slot-btn stop" onclick="stopSlot(event, ${slotNum})" ${!isBusy ? 'disabled' : ''}>Stop</button>
                            </div>
                        `;
                    } else {
                        // For multiplayer, just show role
                        item.innerHTML = `
                            <span>${name}</span>
                            ${role ? `<span class="role-badge ${role}">${role}</span>` : ''}
                        `;
                    }

                    // Add drag events to assigned slot items
                    item.addEventListener('dragstart', handleAssignedSlotDragStart);
                    item.addEventListener('dragend', handleAssignedSlotDragEnd);

                    container.appendChild(item);
                });
            }

            // Update buttons (only for multiplayer)
            if (isMultiplayer) {
                updateAreaButtons(areaId);
            }
        }

        function updateAreaButtons(areaId) {
            const area = document.querySelector(`[data-area-id="${areaId}"]`);
            const startBtn = area.querySelector('.area-btn.start');
            const stopBtn = area.querySelector('.area-btn.stop');
            const assignedSlots = slotAssignments[areaId];

            const isMultiplayer = areaId.includes('mp');
            const hasSlots = assignedSlots.length > 0;
            const hasEnoughSlots = isMultiplayer ? assignedSlots.length >= 2 : hasSlots;

            // Check if any assigned slot is online
            const hasOnlineSlots = assignedSlots.some(slotNum => {
                const slot = slots[`slot_${slotNum}`];
                return slot && slot.online;
            });

            // Check if any assigned slot is running or starting (busy)
            const hasBusySlots = assignedSlots.some(slotNum => {
                const slot = slots[`slot_${slotNum}`];
                const status = slot && slot.setup ? slot.setup.status : 'idle';
                return status === 'running' || status === 'starting';
            });

            startBtn.disabled = !hasEnoughSlots || !hasOnlineSlots || hasBusySlots;
            stopBtn.disabled = !hasBusySlots;
        }

        async function startSlot(event, areaId, slotNum) {
            event.stopPropagation();

            const area = document.querySelector(`[data-area-id="${areaId}"]`);
            const game = area.dataset.game;

            // Optimistically update UI immediately
            const slot = slots[`slot_${slotNum}`];
            if (slot && slot.setup) {
                slot.setup.status = 'starting';
                updateGameArea(areaId);
            }

            try {
                const response = await fetch(`${ORCHESTRATOR_URL}/api/start_slot`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        slot: slotNum,
                        game: game,
                        mode: 'singleplayer'
                    })
                });

                const result = await response.json();

                if (response.ok) {
                    showMessage(`Started ${game} on Slot ${slotNum}`, 'success');
                } else {
                    showMessage(result.error || 'Failed to start game', 'error');
                    // Revert optimistic update on failure
                    updateSlots();
                }

                setTimeout(updateSlots, 1000);
            } catch (error) {
                console.error('Error starting slot:', error);
                showMessage('Error communicating with orchestrator', 'error');
                // Revert optimistic update on error
                updateSlots();
            }
        }

        async function stopSlot(event, slotNum) {
            event.stopPropagation();

            // Find which area this slot belongs to for UI update
            let slotAreaId = null;
            for (const [areaId, assignedSlots] of Object.entries(slotAssignments)) {
                if (areaId !== 'pool' && assignedSlots.includes(slotNum)) {
                    slotAreaId = areaId;
                    break;
                }
            }

            // Optimistically update UI immediately
            const slot = slots[`slot_${slotNum}`];
            if (slot && slot.setup) {
                slot.setup.status = 'idle';
                slot.setup.current_game = null;
                if (slotAreaId) {
                    updateGameArea(slotAreaId);
                }
            }

            try {
                const response = await fetch(`${ORCHESTRATOR_URL}/api/stop_slot`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ slot: slotNum })
                });

                const result = await response.json();

                if (response.ok) {
                    showMessage(`Stopped game on Slot ${slotNum}`, 'success');
                } else {
                    showMessage(result.error || 'Failed to stop game', 'error');
                }

                setTimeout(updateSlots, 1000);
            } catch (error) {
                console.error('Error stopping slot:', error);
                showMessage('Error communicating with orchestrator', 'error');
                // Revert optimistic update on error
                updateSlots();
            }
        }

        async function startArea(areaId) {
            const area = document.querySelector(`[data-area-id="${areaId}"]`);
            const game = area.dataset.game;
            const mode = area.dataset.mode;
            const assignedSlots = slotAssignments[areaId];

            if (assignedSlots.length === 0) {
                showMessage('No slots assigned to this area', 'error');
                return;
            }

            if (mode === 'multiplayer' && assignedSlots.length < 2) {
                showMessage('Multiplayer requires at least 2 slots', 'error');
                return;
            }

            try {
                // Use multiplayer endpoint
                const response = await fetch(`${ORCHESTRATOR_URL}/api/start_multiplayer`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        slots: assignedSlots,
                        game: game
                    })
                });

                const result = await response.json();

                if (response.ok) {
                    showMessage(
                        `Started ${game} multiplayer on ${result.success_count}/${result.total_slots} slots`,
                        result.success_count === result.total_slots ? 'success' : 'error'
                    );
                } else {
                    showMessage(result.error || 'Failed to start multiplayer', 'error');
                }

                setTimeout(updateSlots, 1000);
            } catch (error) {
                console.error('Error starting area:', error);
                showMessage('Error communicating with orchestrator', 'error');
            }
        }

        async function stopArea(areaId) {
            const assignedSlots = slotAssignments[areaId];

            if (assignedSlots.length === 0) {
                showMessage('No slots assigned to this area', 'error');
                return;
            }

            try {
                let successCount = 0;
                for (const slotNum of assignedSlots) {
                    const response = await fetch(`${ORCHESTRATOR_URL}/api/stop_slot`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ slot: slotNum })
                    });

                    if (response.ok) {
                        successCount++;
                    }
                }

                showMessage(
                    `Stopped ${successCount}/${assignedSlots.length} slots`,
                    successCount === assignedSlots.length ? 'success' : 'error'
                );

                setTimeout(updateSlots, 1000);
            } catch (error) {
                console.error('Error stopping area:', error);
                showMessage('Error communicating with orchestrator', 'error');
            }
        }

        async function updateSlots() {
            try {
                const response = await fetch(`${ORCHESTRATOR_URL}/api/setups`);
                const data = await response.json();

                slots = data;

                // Update pool slot cards
                slotAssignments['pool'].forEach(slotNum => {
                    updateSlotCard(slotNum);
                });

                // Update all game areas (re-renders buttons with current state)
                ['f1_sp', 'acc_sp', 'dirt_sp', 'f1_mp1', 'f1_mp2'].forEach(areaId => {
                    updateGameArea(areaId);
                });
            } catch (error) {
                console.error('Error fetching slots:', error);
            }
        }

        function showMessage(text, type) {
            const message = document.getElementById('message');
            message.textContent = text;
            message.className = `message ${type} show`;

            setTimeout(() => {
                message.classList.remove('show');
            }, 5000);
        }

        // Initialize
        initializeSlots();
        updateSlots();
        setInterval(updateSlots, 2000);
    </script>
</body>
</html>
